#!/bin/sh
# This script executes a given XQuery script against a given XML file.
# Requirements: Java, Saxon HE Java implementation of XQuery (minimum version saxon9he.jar and xml-resolver-1.2.jar)

# Global variables required: JAVA_OPTIONS, XQUERY_CLASS_PATH, XQUERY_CLASS

# Options are available to:
# a) Remove the XML declaration from the output
# b) Strip namespace declarations from the output
# c) Indent the output (pretty print)
# d) Convert self-closing elements to start and end tags
# e) Cater for text-only output, to get round Saxon limitations
# f) Supply the xquery inline as a string; or in a separate file
# g) Prepend the xquery with a prolog from a file

# get name of this script
command_name=$(basename "$0");
# get directory of this script
script_path=$(cd "$(dirname "$0")" || exit; pwd);
if [ "$script_path" = "" ] || [ ! -d "$script_path" ] || [ ! -e "$script_path/$command_name" ]; then echo "Variables \$command_name and \$script_path not set correctly for script $command_name"; exit 1; fi;

# get Java version of the directory
script_path_java="$(echo "$script_path" | sed 's%/\([a-z]\)/%/\1:/%';)";
[ "$TMPDIR" == "" ] && echo "$command_name: ERROR: environment variable \$TMPDIR is not set" 1>&2 && exit 1;
[ ! -d "$TMPDIR" ] && echo "$command_name: ERROR: environment variable \$TMPDIR is not set to a valid foder" 1>&2 && exit 1;

# command help
help_usage="

Syntax of $command_name:

$command_name [-t] [-eilox] -s xml_file ( -f xquery_file | -q xquerystring ) [ -p prologfile | -d ]

REQUIRED OPTIONS:
-s        Path to source XML file

-f FILE   Path to file containing partial XQuery
OR
-q QUERY  Partial XQuery as a string

OPTIONAL OPTIONS:
-e        Expands empty elements to start and end tags
-i        Indents output XML using Saxon '!indent=yes'
-l        Text output required. Extracts content of <xqstring></xqstring> 
            elements, one line for each
-o        Strips XML declaration using Saxon '!omit-xml-declaration=yes'
-x        Strips all XML namespaces from output

-p FILE   Path to prolog file. Contents of prolog file prepended to the query
OR
-d        Use the default prolog file in this script's folder

-a FILE   Append this file to the prolog file

-t        Output the generated Java command to STDERR; do not run the command

Examples: 
$command_name 
$command_name -s mds201199a.xml -q 'let \$p:=.//pp return \$p'
$command_name -s mds201199a.xml -f myquery.xqy -o

";

# set query variables to empty values
query="";
query_file="";
user_query_file="";
output_xml_dec="";
indent_xml="";


default_prolog_file="${script_path}/xq_prolog";
append_to_prolog_file="${script_path}/xquery_prolog";
prolog="";
user_query_file="";
user_prolog_file="";
use_default_prolog_file=0;
strip_string_element=0;
strip_xml_namespaces=0;
expand_empty_elements=0;
test_query=0;

# read command options
while getopts "deilotxs:q:f:p:h?" getopts_option
do
  case $getopts_option in
    t ) test_query=1;;
    s ) xml_file="$OPTARG";;
    q ) query="$OPTARG";;	
    f ) user_query_file="$OPTARG";; 
    p ) user_prolog_file="$OPTARG";;
    d ) use_default_prolog_file=1;;
    a ) append_to_prolog_file="$OPTARG";;
    o ) output_xml_dec='!omit-xml-declaration=yes';;
    l ) strip_string_element=1;;
    e ) expand_empty_elements=1;;
    i ) indent_xml='!indent=yes';;
    x ) strip_xml_namespaces=1;;
    h | \? ) echo "$help_usage"; exit 0;;
  esac
done;
# move shell command-line-argument pointer to end of options
shift $((OPTIND - 1));

# validate options
# options -f and -q are required and mutually exclusive
[ "$query" = "" ] && [ "$user_query_file" = "" ] && echo "Must specify either -q or -f;$help_usage" 1>&2 && exit 1;
[ "$query" != "" ] && [ "$user_query_file" != "" ] && echo "Can't specify both -q and -f;$help_usage" 1>&2 && exit 1;

# xquery_prolog file must exist if specified
if [ "$append_to_prolog_file" != "" ] && [ ! -e "$append_to_prolog_file" ]; then
	echo "ERROR: $command_name: Can't find required xquery file for setting \$root $append_to_prolog_file" 1>&2; 
	exit 1 ;
fi;

# source XML file is required and must exist
[ "$xml_file" = "" ] && echo "-s (source XML file) is required;$help_usage" 1>&2 && exit 1;
[ ! -e "$xml_file" ] && echo "Can't find source XML file $xml_file;$help_usage" 1>&2 && exit 1;

# if partial query file is given, it must exist
if [ "$user_query_file" != "" ]; then
	[ ! -e "$user_query_file" ] && echo "Can't find XQuery file $user_query_file;$help_usage" 1>&2 && exit 1;
fi;

# if prolog file given, it must exist
if [ "$user_prolog_file" != "" ]; then
	if [ ! -e "$user_prolog_file" ]; then
		echo "ERROR: $command_name: Can't find prolog file $user_prolog_file;$help_usage" 1>&2; exit 1 ;
	fi;
fi;

# options -p and -d are optional but mutually exclusive, if one is given, it must exist, read it if it does
if [ "$use_default_prolog_file" -ne 0 ]; then
    if [ "$user_prolog_file" != "" ]; then
	    echo "Can't specify both -p and -d;$help_usage" 1>&2 && exit 1;
	else
	    if [ ! -e "$default_prolog_file" ]; then
		   echo "ERROR: $command_name: Can't find prolog file $default_prolog_file;$help_usage" 1>&2; exit 1 ;
		else
	        prolog=$(sed "s%SCRIPTS_PATH%${SCRIPTS_PATH_JAVA}%g" "$default_prolog_file");
		fi;
	fi;
else 
    if [ "$user_prolog_file" != "" ]; then
	    if [ ! -e "$user_prolog_file" ]; then
		   echo "ERROR: $command_name: Can't find prolog file $user_prolog_file;$help_usage" 1>&2; exit 1 ;
		else
	        prolog=$(sed "s%SCRIPTS_PATH%${SCRIPTS_PATH_JAVA}%g" "$user_prolog_file");
		fi;
	fi;
fi;

# if prolog append file given, it must exist, append it if it does
if [ "$append_to_prolog_file" != "" ]; then
	if [ -f "$append_to_prolog_file" ]; then
		xquery_prolog=$(cat "$append_to_prolog_file");
	else
		echo "ERROR: $command_name: Can't find prolog file $append_to_prolog_file;$help_usage" 1>&2; exit 1 ;
	fi
else
	xquery_prolog="";
fi;

# combine prolog and xquery_prolog
this_prolog="$prolog $xquery_prolog";

# replace any variables defined

# count the number of replacements to make
rep_count=$(echo "$this_prolog" | egrep -o 'VAR:![A-Za-z_:]*!' | sort | uniq | wc -l);
if [ "$rep_count" -eq "0" ]; then
	: ;
else
	rep_no=0;
	# get list of unique variable references , separated by spaces
	vars_to_replace=$(echo "$this_prolog" | egrep -o 'VAR:![A-Za-z_:]*!' | sort | uniq | xargs echo);
	# loop through variable references
	# echo "$this_prolog" | egrep -o 'VAR:![A-Za-z_:]*!' | sort | uniq | while read -r var_ref_string; do
	# infinite loop
	while true; do
	# get next variable from list
	var_ref_string=${vars_to_replace%% *};
	# increment the current replacement number
	rep_no=$(( rep_no + 1));
	# get the variable name from the reference string
	var_ref=$(echo "$var_ref_string" | sed 's%^VAR:!%%;s%!%%');
	# separate the variable name into any prefix denoting variable value processing,
	# and the variable name itself, using :
	var_ref_name=${var_ref#*:};
	var_ref_prefix=${var_ref%:*};
	# parameter expansion of type % returns the full value if the expression is not found
	# in this case, set the prefix to empty text
	if [ "$var_ref_prefix" == "$var_ref_name" ]; then 
		var_ref_prefix="";
	fi;

	# test that the variable is set, and is not the empty string
	if [ -z "${!var_ref_name}" ]; then
		echo "ERROR: $command_name: variable ${var_ref_name} is not defined or is empty;$help_usage" 1>&2; exit 1 ;
	fi

	# get the value of the variable
	var_replacement=${!var_ref_name};
	
	# do any variable processing indicated by the prefix, if it exists
	# note: currently, only prefix "java_path" is supported
	if [ "$var_ref_prefix" != "" ]; then
		if [ "$var_ref_prefix" == "java_path" ]; then
			# convert the variable from a Unix path to a Java path
			var_replacement="$(echo "$var_replacement" | sed 's%/\([a-z]\)/%/\1:/%';)";
		else
			echo "ERROR: $command_name: $var_ref_prefix is not a recognised variable processing prefix;$help_usage" 1>&2; exit 1 ;
		fi;
	fi;
	# if the variable referenced exists and has a value
	if [ "$var_replacement" != "" ]; then
		# replace the variable reference string with the value of the variable
		if [ "$this_prolog" == "" ]; then
			this_prolog=$(echo "$this_prolog" | sed "s%$var_ref_string%$var_replacement%g");
		else
			this_prolog=$(echo "$this_prolog" | sed "s%$var_ref_string%$var_replacement%g");
		fi;
	fi
	# output the replaced text if the last replacement has been reached
	#if [ "$rep_no" -eq "$rep_count" ]; then echo "$this_prolog"; fi;

	# exit infinite loop if variable is last variable in list
	if [ "$(echo "$vars_to_replace" | grep -F ' ')" == "" ]; then
		break;
	fi;
	# remove first variable from remaining list
	vars_to_replace=${vars_to_replace#* };
	done;
fi

if [ "$user_query_file" != "" ]; then
	# option f chosen, xquery is a file, create new file combining it with prolog file
	#    and files processing prolog file
	# save in /tmp folder
	query_file=$(mktemp -t tmp.XXXXXXXXXX) || echo "$command_name: ERROR: \"mktemp\" command failed." 1>&2 ;
	# combine prolog file and user query file to get temporary query file
	(echo  "$this_prolog"; echo "$query "; cat "$user_query_file") > "$query_file";
else
	# option q chosen, create query string
	query_string="$this_prolog $query";
fi;

# run xquery, get raw result
if [ "$query" != "" ]; then 
    if [ "$test_query" -eq 1 ]; then
        echo "java $JAVA_OPTIONS -cp \"$XQUERY_CLASS_PATH\" \"$XQUERY_CLASS\" $XQUERY_OPTIONS -s:\"$xml_file\" -qs:\"$query_string\" $output_xml_dec $indent_xml";
        exit 0;
    else
        xq_result=$(java $JAVA_OPTIONS -cp "$XQUERY_CLASS_PATH" "$XQUERY_CLASS" $XQUERY_OPTIONS -s:"$xml_file" -qs:"$query_string" $output_xml_dec $indent_xml);
	    exit_code=$?;
    fi; 
else
    if [ "$test_query" -eq 1 ]; then
        echo "java $JAVA_OPTIONS -cp \"$XQUERY_CLASS_PATH\" \"$XQUERY_CLASS\" $XQUERY_OPTIONS -s:\"$xml_file\" -q:\"$query_file\" $output_xml_dec $indent_xml";
        exit 0;
    else
        xq_result=$(java $JAVA_OPTIONS -cp "$XQUERY_CLASS_PATH" "$XQUERY_CLASS" $XQUERY_OPTIONS -s:"$xml_file" -q:"$query_file" $output_xml_dec $indent_xml);
	    exit_code=$?;
    fi; 
fi;

# exit if java xquery call fails
if [ "$exit_code" != 0 ]; then exit $exit_code; fi;

# strip namespace declarations if requested
if [ "$strip_xml_namespaces" -ne 0 ]; then xq_result="$(echo "$xq_result" | sed -r 's% xmlns:[A-Za-z_][A-Za-z_0-9.-]*="[^"]*"%%g; s% xmlns="[^"]*"%%g' | sed ':a;$!{N;ba};s%[[:space:]]*>%>%g')"; fi;

#if [ "$strip_string_element" -eq 1 ]; then xq_result="$(echo "$xq_result" | sed -r 's%^[[:space:]]*<xqstring>%%;s%</xqstring>[[:space:]]*$%%g;s%</xqstring><xqstring>%\n%g;')"; fi;;
if [ "$strip_string_element" -eq 1 ]; then xq_result="$(echo "$xq_result" | sed -r 's%[[:space:]]*<xqstring>%%g;s%</xqstring>[[:space:]]*%\n%g;' | sed '/^[[:space:]]*$/d')"; fi;

if [ "$expand_empty_elements" -eq 1 ]; then xq_result="$(echo "$xq_result" | sed -r 's%<([^>[[:space:]]]*)([^>]*)/>%<\1\2></\1>%g')"; fi;

[ "$xq_result" != "" ] && echo "$xq_result";
#echo
exit 0;

