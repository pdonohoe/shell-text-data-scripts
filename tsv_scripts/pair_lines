#!/bin/sh

# pairlines reads all lines from input or a file
# It creates lines consisting of pairs of the original lines, separated by a space.  
# Each pair item may be quoted
# So:
# line1
# line2
# line3
# line4
# line5
# becomes:
# line1 line2
# line2 line3
# line3 line4
# line4 line5


# get name of this script
command_name=$(basename "$0");
# get directory of this script
script_path=$(cd "$(dirname "$0")" || exit; pwd);
if [ "$script_path" = "" ] || [ ! -d "$script_path" ] || [ ! -e "$script_path/$command_name" ]; then echo "Variables \$command_name and \$script_path not set correctly for script $command_name"; exit 1; fi;

# command help
help_usage="
Syntax: 
$command_name [ -s | -d ] file
[ lines ] | $command_name [ -s | -d ]

Options
-? : Print this summary
-s : Use single quotes around each line
-d : Use double quotes around each line
";

single=0;
double=0;
# read command options
while getopts "sdh?" getopts_option
do
  case $getopts_option in
    s ) single=1;;	
    d ) double=1;;	
	h | \? ) echo "$help_usage"; exit 0;
  esac
done;
# move shell command-line-argument pointer to end of options
shift $((OPTIND - 1));
# validate options


# Validate options
if [ "$single" = 1 ] && [ "$double" = 1 ]; then 
    echo "ERROR: $command_name: -s and -d may not be used together;$help_usage" 1>&2; 
    exit 0 ; 
fi;

# create quote character
if [ "$single" -eq 1 ]; then quote="'";
elif [ "$double" -eq 1 ]; then quote='"';
else quote='';
fi;


if [ "$#" -gt 1 ]; then 
    echo "ERROR! $command_name requires zero or one argument.;$help_usage" 1>&2; exit 0 ; 
fi;

if [ "$#" = 1 ] && [ ! -e "$1" ]; then
    echo "ERROR! $command_name cant read file $1.;$help_usage" 1>&2; exit 0 ; 
fi;

first_line=1;
previous_line="";

case $# in
	# no lines given as parameters to command, use STDIN
	0) num_lines=0;
		while IFS="$(printf '\n')" read -r line; do
			if [ "$first_line" = 1 ]; then 
				first_line=0;
				previous_line=$line;
			else
				echo "$quote""$previous_line""$quote" "$quote""$line""$quote";
				previous_line=$line;
			fi;
			num_lines=$((num_lines + 1));
			if [ "$num_lines" -gt 10 ]; then
				echo "ERROR! terminating at 10 lines." 1>&2; exit 0 ; 
			fi;
		done;;
	1) num_lines=0;
		while IFS="$(printf '\n')" read -r line; do
			if [ "$first_line" = 1 ]; then 
				first_line=0;
				previous_line=$line;
			else
				echo "$quote""$previous_line""$quote" "$quote""$line""$quote";
				previous_line=$line;
			fi;
			num_lines=$((num_lines + 1));
			if [ "$num_lines" -gt 10 ]; then
				echo "ERROR! terminating at 10 lines." 1>&2; exit 0 ; 
			fi;
		done < "$1";
esac;


