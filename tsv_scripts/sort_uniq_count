#!/bin/sh
# This script reads a sequence of lines from STDIN, and 
# outputs the unique lines, sorted.
# It prepends the count of each line to a new first column.
# Then re-sorts the output numerically by the count

# get name of this script
command_name=$(basename "$0");
# get directory of this script
script_path=$(cd "$(dirname "$0")" || exit; pwd);
if [ "$script_path" = "" ] || [ ! -d "$script_path" ] || [ ! -e "$script_path/$command_name" ]; then echo "Variables \$command_name and \$script_path not set correctly for script $command_name"; exit 1; fi;

# set default options values
sortby="number";
reverse=0;

# command help
help_usage="
$command_name returns the unique lines from STDIN, sorted
It prepends the count of each unique line as a new first column
Then re-sorts the output numerically by the count

Syntax of $command_name:

[ LINES ] | $command_name [ -s sortby ] [ -r ]

OPTIONAL OPTIONS:
-s sortby specify whether to sort by count of lines (default) or line text
-r      Reverse the sort output

";

# read command options
while getopts "rs:h?" getopts_option
do
  case $getopts_option in
   s) sortby="$OPTARG";;
   r) reverse=1;;
   h | \? ) echo "$help_usage"; exit 0;
  esac
done;
# move shell command-line-argument pointer to end of options
shift $((OPTIND - 1));

# validate options

if [ "$( echo "$sortby" | egrep "^(n|number|l|line)$")" == "" ]; then 
  echo "Option -s must be one of: n number;$help_usage" 1>&2 && exit 0;
fi;

# normalise sortby to full words
[ "$sortby" = "n" ] && sortby="number";

if [ $reverse -eq 0 ]; then
  # output order is not reversed
  if [ $sortby == "number" ]; then
    # output by count of line instances
    awk 'BEGIN {OFS=""; } END {n=asorti(myhash, sorted); for (i=1; i<=n; i++) { print myhash[sorted[i]], "\t", sorted[i]; } } { myhash[$0]++; }' | sort -t$'\t' -k1,1n
  else
    # order by line text
    awk 'BEGIN {OFS=""; } END {n=asorti(myhash, sorted); for (i=1; i<=n; i++) { print myhash[sorted[i]], "\t", sorted[i]; } } { myhash[$0]++; }' | sort -t$'\t' -k2
  fi;
else
  # output order is reversed
  if [ $sortby == "number" ]; then
    # output by count of line instances
    awk 'BEGIN {OFS=""; } END {n=asorti(myhash, sorted); for (i=n; i>=1; i--) { print myhash[sorted[i]], "\t", sorted[i]; } } { myhash[$0]++; }' | sort -t$'\t' -k1,1nr
  else
    # order by line text
    awk 'BEGIN {OFS=""; } END {n=asorti(myhash, sorted); for (i=1; i<=n; i++) { print myhash[sorted[i]], "\t", sorted[i]; } } { myhash[$0]++; }' | sort -t$'\t' -k2r
  fi;
fi;