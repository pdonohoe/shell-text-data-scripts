#!/bin/sh
# This script reads a sequence of lines from STDIN, and 
# outputs the unique lines, sorted.
# It prepends the count of each line to a new first column.
# Then re-sorts the output numerically by the count

# get name of this script
command_name=$(basename "$0");
# get directory of this script
script_path=$(cd "$(dirname "$0")" || exit; pwd);
if [ "$script_path" = "" ] || [ ! -d "$script_path" ] || [ ! -e "$script_path/$command_name" ]; then echo "Variables \$command_name and \$script_path not set correctly for script $command_name"; exit 1; fi;

# set default options values
sortby="number";
reverse=0;

# command help
help_usage="
$command_name returns the unique lines from STDIN, sorted
It prepends the count of each unique line as a new first column
Then re-sorts the output numerically by the count

Syntax of $command_name:

[ LINES ] | $command_name [ -s [ l | c | count | line ] ]  [ -o [ a | alpha | n | numeric | number ] ] [ -r ]

OPTIONAL OPTIONS:
-s sortby     specify whether to sort by count of lines (default) or line text
                c or l or count or line
-o ordertype  specify the order type to use for count by line text (alpha, numerical)
                a or n or alpha or numeric or number
                If sortby is count then ordertype is numeric
-r            Reverse the sort output

";

# set default sort by to count of lines
sortby="count";
ordertype="alpha";

# read command options
while getopts "rs:o:h?" getopts_option
do
  case $getopts_option in
   s) sortby="$OPTARG";;
   o) ordertype="$OPTARG";;
   r) reverse=1;;
   h | \? ) echo "$help_usage"; exit 0;
  esac
done;
# move shell command-line-argument pointer to end of options
shift $((OPTIND - 1));

# validate options

# option -s must be one of c count l line
if [ "$( echo "$sortby" | egrep "^(c|count|l|line)$")" == "" ]; then 
  echo "$command_name: ERROR: Option -s must be one of: c count l line;$help_usage" 1>&2 && exit 0;
fi;

# option -o must be one of a n alpha numeric number
if  [ "$( echo "$sortby" | egrep "^(l|line)$")" != "" ] && [ "$( echo "$ordertype" | egrep "^(a|n|alpha|numeric|number)$")" == "" ]; then 
  echo "$command_name: ERROR: Option -o must be one of: a alpha n numeric number;$help_usage" 1>&2 && exit 0;
fi;

# normalise sortby to full word
[ "$sortby" = "c" ] && sortby="count";

# ordertype is numeric if sortby is count
[ "$sortby" = "count" ] && ordertype="numeric";

# normalise ordertype to full word
[ "$ordertype" = "n" ] && ordertype="numeric";
[ "$ordertype" = "number" ] && ordertype="numeric";

if [ "$reverse" -eq 0 ]; then
  # output order is not reversed
  if [ $sortby == "count" ]; then
    # output by count of line instances, numeric sort
    awk 'BEGIN {OFS=""; } END {n=asorti(myhash, sorted); for (i=1; i<=n; i++) { print myhash[sorted[i]], "\t", sorted[i]; } } { myhash[$0]++; }' | sort -t$'\t' -k1,1n
  else
    if [ "$ordertype" == "numeric" ]; then
      # order by line text, numeric sort
      awk 'BEGIN {OFS=""; } END {n=asorti(myhash, sorted); for (i=1; i<=n; i++) { print myhash[sorted[i]], "\t", sorted[i]; } } { myhash[$0]++; }' | sort -t$'\t' -k2n
    else
      # order by line text, alpha sort
      awk 'BEGIN {OFS=""; } END {n=asorti(myhash, sorted); for (i=1; i<=n; i++) { print myhash[sorted[i]], "\t", sorted[i]; } } { myhash[$0]++; }' | sort -t$'\t' -k2
    fi;
  fi;
else
  # output order is reversed
  if [ $sortby == "count" ]; then
    # output by count of line instances
    awk 'BEGIN {OFS=""; } END {n=asorti(myhash, sorted); for (i=n; i>=1; i--) { print myhash[sorted[i]], "\t", sorted[i]; } } { myhash[$0]++; }' | sort -t$'\t' -k1,1nr
  else
      if [ $ordertype == "numeric" ]; then
      # order by line text, numeric sort
      awk 'BEGIN {OFS=""; } END {n=asorti(myhash, sorted); for (i=1; i<=n; i++) { print myhash[sorted[i]], "\t", sorted[i]; } } { myhash[$0]++; }' | sort -t$'\t' -k2nr
    else
      # order by line text, alpha sort
      awk 'BEGIN {OFS=""; } END {n=asorti(myhash, sorted); for (i=1; i<=n; i++) { print myhash[sorted[i]], "\t", sorted[i]; } } { myhash[$0]++; }' | sort -t$'\t' -k2r
    fi;
  fi;
fi;